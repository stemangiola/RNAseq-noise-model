---
title: "Generated quantities"
output: html_notebook
---

This notebook display the generated quantities of each model, with no data imput

```{r setup}
# Import libraries

set.seed(13254)

# Import libraries
library(tidyverse)
library(magrittr)
library(rstan)
library(tidybayes)
library(here)
library(foreach)
library(doParallel)
registerDoParallel()
# library(future)
# plan(multiprocess)

rstan_options(auto_write = TRUE)
options(mc.cores = parallel::detectCores())

#devtools::load_all() # Sorry this costs me 30 minutes every day
```

Setting global variables

```{r}

N = 20
G = 30
counts_source = "Acute_Myeloid_Leukemia_Primary_Blood_Derived_Cancer_-_Peripheral_Blood"

# Evaluate whether to recompute input data frame
temp_file_counts = here("local_temp_data",paste0("subset_", counts_source,".rds"))
if(!file.exists(temp_file_counts)) {
  recompute_counts_tidy = TRUE
} else {
  counts_data <- readRDS(temp_file_counts)
  if(counts_data$N != N || counts_data$G != G) {
    recompute_counts_tidy = TRUE
  } else {
    counts_tidy = counts_data$counts_tidy
    recompute_counts_tidy = FALSE
  }
}

if(recompute_counts_tidy) {
  # Import gene transcription data set
  counts_tidy =
    read_csv(here("big_data", "tibble_TCGA_files", paste0(counts_source, ".csv"))) %>%
    filter(sample %in% ( (.) %>% distinct(sample) %>% head(n=N) %>% pull(sample)) ) %>%
    filter(ens_iso %in% ( (.) %>% distinct(ens_iso) %>% head(n=G) %>% pull(ens_iso)) ) %>%
    mutate_if(is.character, as.factor) %>%

    # Add numerical indexes
    left_join(
      (.) %>%
        distinct(ens_iso) %>%
        arrange(ens_iso) %>%
        mutate(ens_iso_idx = 1:n())
    ) %>%
    left_join(
      (.) %>%
        distinct(sample) %>%
        arrange(sample) %>%
        mutate(sample_idx = 1:n())
    )

  counts_data = list(N = N, G = G, counts_tidy = counts_tidy)
  saveRDS(counts_data, file = temp_file_counts)
}

# Produce input for Stan
```

Select skewed genes

```{r}


 tbl =    
  read_csv(here("big_data", "tibble_TCGA_files", paste0(counts_source, ".csv"))) %>%
  mutate_if(is.character, as.factor) %>%
  group_by(ens_iso) %>%
  do(
    (.) %>%
      mutate(
        pvalue_normal = ifelse(
          (.) %>% distinct(`read count`) %>% nrow > 1,
          (.) %>% 
          pull(`read count`) %>% 
          `+` (1) %>% 
          log %>% 
          shapiro.test %$% 
          p.value ,
          NA
        )
      ) 
  ) %>% 
  ungroup()

 tbl %>%
   right_join(
     (.) %>% group_by(ens_iso) %>% summarise(m = `read count` %>% median) %>% arrange(m %>% desc) %>% head(n = 30000)
   ) %>%
   right_join(
     (.) %>% ungroup %>% distinct(ens_iso, pvalue_normal) %>% arrange(pvalue_normal %>% desc) %>% head(n=10) %>% dplyr::select(ens_iso)
   ) %>%
   ggplot(aes(x=ens_iso, y=`read count`)) + geom_boxplot() + scale_y_log10() + my_theme
 
 
read_csv(here("big_data", "tibble_TCGA_files", paste0(counts_source, ".csv"))) %>%
  
  # Take the highest expressed
  mutate_if(is.character, as.factor) %>%
    right_join(
     (.) %>% group_by(ens_iso) %>% summarise(m = `read count` %>% median) %>% arrange(m %>% desc) %>% head(n = 10000)
   ) %>%
  
  # Take the ones with bigger ratio sd / median
   right_join(
     (.) %>%
       group_by(ens_iso) %>%
    summarise(
      med = `read count` %>% `+` (1) %>% median, 
      sd = `read count` %>% `+` (1) %>% sd
    ) %>%
     mutate(ratio = log(sd)/log(med+1)) %>%
     arrange(ratio %>% desc) %>%
     head(n=20)
   ) %>%
  
  # Infer NB
   #group_by(ens_iso) %>%
  multidplyr::partition(ens_iso) %>%
   do({
 
     `%>%` = magrittr::`%>%`
		library(tidyverse)
		library(magrittr)
     # lines(seq(0,1000, 10) , sapply(seq(0,1000, 10)  , gamlss.dist::dSICHEL,mu= 100, sigma=0.05, nu=-0.3, log=T))
     
    fit_NB =  (.) %>%
       arrange(`read count`) %>%
       pull(`read count`) %>%
      MASS::fitdistr("Negative Binomial")
    
    fit_SH =  (.) %>%
       arrange(`read count`) %>%
       pull(`read count`) %>%
      MASS::fitdistr(gamlss.dist::dSICHEL, list(mu= 100, sigma=0.1, nu=-5), upper = c(4000, 20, 0),  lower=c(0, 0.0001, -10))

    
    (.) %>%
       arrange(`read count`) %>%
      mutate(predicted_NB = qnbinom(ppoints(`read count`), size=(fit_NB[1] %$% estimate)[1], mu=(fit_NB[1] %$% estimate)[2])) %>%
      mutate(predicted_SH = gamlss.dist::qSICHEL(ppoints(`read count`), nu = (fit_SH[1] %$% estimate)[3], sigma=(fit_SH[1] %$% estimate)[2], mu=(fit_SH[1] %$% estimate)[1], max.value = max(`read count`))) %>%
      mutate(
        SH_mu = (fit_SH[1] %$% estimate)[1], 
        SH_sigma = (fit_SH[1] %$% estimate)[2],
        SH_nu = (fit_SH[1] %$% estimate)[3]
        )
      
 }   ) %>%
     collect() %>%
	ungroup() %>%
  
  # Plot
 {
   
   browser()

  (.) %>%
     gather(model, predicted, c("predicted_NB", "predicted_SH")) %>%
     ggplot(aes(x=`predicted` + 1, y=`read count` + 1, label=ens_iso, color=model)) + 
      geom_abline(intercept = 0, slope = 1, color="grey") + 
      geom_line() + 
     facet_wrap(~ ens_iso, scales = "free")  + my_theme +
     expand_limits(y=1, x=1) + scale_y_log10() + scale_x_log10() 
   
   (.) %>% 
     ggplot(aes(x= ens_iso,y=`read count` + 1, fill=ens_iso)) +
     geom_boxplot(outlier.size = 0, lwd=0.2, position = position_dodge(width=0.8)) +
     geom_point(position=position_jitterdodge(dodge.width=0.8), size = 0.2, shape = 21 ) + 
     scale_y_log10() + my_theme
   
   (.)
}
   
 
  
  
  xxx %>% {
     (.) %>% ggplot(aes(x=average, y=sd^2, label=ens_iso)) + geom_point() + scale_y_log10() + scale_x_log10() + my_theme
  } %>%
   plotly::ggplotly()
 
  xxx %>% filter(grepl("169429|196557", ens_iso )) %>% ggplot(aes(x= ens_iso,y=`read count`, fill=ens_iso)) +
   	geom_boxplot(outlier.size = 0, lwd=0.2, position = position_dodge(width=0.8)) +
   geom_point(position=position_jitterdodge(dodge.width=0.8), size = 0.2, shape = 21 ) + scale_y_log10()
   
  library(MASS)
  data = xxx %>% filter(grepl("169429", ens_iso )) %>% pull(`read count`)
 params = fitdistr(data, "Negative Binomial")

   data.s = sort(data)

data.q <- qnbinom(ppoints(data), size=(params[1] %$% estimate)[1], mu=(params[1] %$% estimate)[2])

plot(data.q, data.s, col="red", xlab="Negative Binomial theoretical quantiles", ylab="Data quantiles")
 
# plot the reference line
abline(0,1)
 
  d_adj %>%
   group_by(symbol) %>%
  summarise(
    average = `value normalised` %>% `+` (1) %>% median, 
    sd = `value normalised` %>% `+` (1) %>% sd
  ) %>%
  {
     (.) %>% ggplot(aes(x=average, y=sd^2, label=symbol)) + geom_point() + scale_y_log10() + scale_x_log10() + my_theme
  } %>%
   plotly::ggplotly()
 
 d_adj %>% filter(grepl("CYP1A1|IGHG1|IGKV1-39|ATF3", symbol )) %>% ggplot(aes(x= symbol,y=`value normalised`, fill=symbol)) +
   	geom_boxplot(outlier.size = 0, lwd=0.2, position = position_dodge(width=0.8)) +
   geom_point(position=position_jitterdodge(dodge.width=0.8), size = 0.2, shape = 21 ) + scale_y_log10()
 

```

Wrappers and utilities

```{r}
source(here("R", "evaluation_tools.R"))
check_return = function(fit){
  fit %>% check_all_diagnostics()
  fit
}

sampling_check_return = function(model, cores = 4, iter = 500, ...){
  sampling(model, cores = cores, iter = iter, ...) %>% check_return
}

# Set theme plots
my_theme = 	
	theme_bw() +
	theme(
		panel.border = element_blank(),
		axis.line = element_line(),
		panel.grid.major = element_line(size = 0.2),
		panel.grid.minor = element_line(size = 0.1),
		text = element_text(size=12),
		legend.position="bottom",
		aspect.ratio=1,
		axis.text.x = element_text(angle = 90, hjust = 1),
		strip.background = element_blank(),
		axis.title.x  = element_text(margin = margin(t = 10, r = 10, b = 10, l = 10)),
		axis.title.y  = element_text(margin = margin(t = 10, r = 10, b = 10, l = 10))
	)


```

```{r}
data_for_stan = list(
  N = N,
  G = G,
  counts =
    counts_tidy %>%
    select(ens_iso,`read count`,sample) %>%
    spread(ens_iso, `read count`) %>%
    select(-sample) %>%
    as.matrix(),

  # Info on data set
  my_prior = c(0,5),
  omit_data = 0,
  generate_quantities = 1,
  is_prior_asymetric = 0,
  exposure =
    counts_tidy %>%
    group_by(sample) %>%
    summarise(`Total counts` = sum(`read count`)) %>%
    pull(`Total counts`)
)
```

Set model names

```{r}
# model_names =
#   dir(path = here("stan"), pattern = ".stan") %>%
#   gsub("\\.stan", "", .)
model_names = c(
  "logNormal_multinomial",
  "logStudent_multinomial",
  "negBinomial",
  "multinomial",
  "dirichlet_multinomial",
  "gamma_multinomial"
  )
```

Compile all models

```{r, echo=FALSE}
models =
  foreach(model_name = model_names) %do% {
    library(rstan) #On Windows, %dopar%-ed code does not share the main session
    library(here) #On Windows, %dopar%-ed code does not share the main session
    stan_model(here("stan",sprintf("%s.stan", model_name)))
  } %>%
  setNames(model_names)
```

Run all models - MARTIN

```{r}
# model_defs = tibble(model_name = model_names) %>% 
#   crossing(tibble(is_prior_asymetric = c(0,1))) %>%
#   filter(model_name != "gamma_multinomial" | is_prior_asymetric == 0) #gamma_multinomial currently does not support assymetric prior
# 
# 
# models_list = models[model_defs$model_name]
# 
# control_list = model_defs %>% rowwise() %>% do(list(max_treedepth = switch(
#           model_name,
#           "logNormal_multinomial" = 12,
#           "logStudent_multinomial" = 13,
#           10)
#   )
# )
# 
# #Copy the data for all runs
# data_list = list()
# for(i in 1:length(control_list)) {
#   data_list[[i]] = data_for_stan
#   
# }
# 
# fits = sampling_multi(models, data_list, control_per_item = control_list) %>%
#   setNames(model_names)
```

Run all models - STEFANO

```{r}
fits =
  foreach(model = models, model_name = models %>% names, .combine = c) %:%
  foreach(is_prior_asymetric = c(0,1), .combine = c) %do% {

    # Trick for naming list
    my_list = list()
    my_list[[sprintf("%s_asymmetric-%s", model_name, is_prior_asymetric)]] =
      sampling_check_return(
        model,
        data =
          data_for_stan %>%
          lplyr::mutate(is_prior_asymetric = is_prior_asymetric),
        control = list(
          max_treedepth = switch(
            model_name,
            "logNormal_multinomial" = 12,
            "logStudent_multinomial" = 13,
            10
          )
        )
      )

    # Return
    my_list
  }

# Fit a single model
fits$`PIG` =
  sampling_check_return(
     stan_model(here("stan",sprintf("%s.stan", "poisson_inverseGaussian"))),
    data = data_for_stan %>% lplyr::mutate(is_prior_asymetric = 1) %>%  lplyr::mutate(omit_data = 1),
    control = list( max_treedepth = 10), chains=1
)
```


Test poisson-GIG

```{r}

fit.PGIG =
  sampling_check_return(
     stan_model(here("stan",sprintf("%s.stan", "poisson_inverseGaussian"))),
    data = data_for_stan %>% lplyr::mutate(is_prior_asymetric = 1),
    control = list( max_treedepth = 10)
)

```

Show speed of the models

```{r}
fits %>% map_dbl(function(x) { sum(get_elapsed_time(x))})
```



Get generated quantities

```{r}
generated_quant =
  foreach(fit = fits, model_name = fits %>% names, .combine = bind_rows) %dopar% {
    library(dplyr) #On Windows, %dopar%-ed code does not share the main session
    library(tidybayes)
    fit %>%
      gather_samples(counts_gen_naive[sample_idx, ens_iso_idx], counts_gen_geneWise[sample_idx, ens_iso_idx]) %>%
      ungroup() %>%
      mutate(model_name)
  } %>%
  left_join(counts_tidy) %>%
  rename(Observed = `read count`, Estimated = estimate)

```

Plots

```{r}

# Overall distribution
generated_quant %>%
  gather(`Source`, `Read count`, c("Observed", "Estimated")) %>%
  filter(.iteration %in% 1:50 & .chain %in% 1) %>%
  mutate(term = gsub("counts_gen_", "", term)) %>%

  # Plot
  {
    (.) %>%
    ggplot(aes(`Read count` + 1, color = Source)) +
    stat_bin(geom = "step", position = "identity", bins=50, alpha = 0.7) +
    facet_grid(term ~ model_name) +
    scale_x_log10() +
    scale_color_brewer(palette = "Set1") +
    my_theme +
    theme(
    strip.text.y = element_text(angle = 0),
    strip.text.x = element_text(angle = 90, size=8)
    ) +
    ggtitle("Overall read count distribution")
  } %>%

  # Save plot
  {
    ggsave(plot = (.), here("dev", "overall_read_count_distribution.png"))
    (.)
  }

# Gene-wise distribution
generated_quant %>%
  gather(`Source`, `Read count`, c("Observed", "Estimated")) %>%
  filter(.iteration %in% 1:50 & .chain %in% 1) %>%
  filter(term == "counts_gen_geneWise") %>%
  right_join( (.) %>% distinct(ens_iso) %>% head(n=20) ) %>%

  # Gene-wise plots
  {
    (.) %>%
    ggplot(aes(`Read count` + 1, color = Source)) +
    stat_bin(geom = "step", position = "identity", bins=50, size=0.2, alpha = 0.7 ) +
    facet_grid(model_name ~ ens_iso) +
    scale_x_log10() +
    scale_color_brewer(palette = "Set1") +
      #scale_size()
    my_theme +
    theme(
      strip.text.y = element_text(angle = 0),
      strip.text.x = element_text(angle = 90, size=8)
    ) +
    ggtitle("Gene-wise read count distribution")
  } %>%

  # Save plot
  {
    ggsave(plot = (.), here("dev", "gene_wise_read_count_distribution.png"), width=29, height=21, units = "cm")
    (.)
  }


```
