---
title: "Testing Waring"
output: html_notebook
---

```{r setup}
library(rstan)
library(gamlss.dist)
library(tidyverse)
library(cowplot)
library(here)
theme_set(theme_cowplot())
options(mc.cores = parallel::detectCores())
rstan_options(auto_write = TRUE)
devtools::load_all()
```


Testing different parametrizations

Direct parametrization.

```{r}
gwaring_raw_lpmf <- function(y, a, k, rho) {
  lgamma(a + rho) + lgamma(k + rho) - lgamma(rho) - lgamma(a + k + rho) + lgamma(a + y) - lgamma(a) + lgamma(k + y) - lgamma(k) - lgamma(a + k + rho + y) + lgamma(a + k + rho) - lgamma(y + 1)
}


gwaring_lpmf <- function(y, mu, k, rho) {
  a <- mu * (rho - 1) / k
  lgamma(a + rho) + lgamma(k + rho) - lgamma(rho) - lgamma(a + k + rho) + lgamma(a + y) - lgamma(a) + lgamma(k + y) - lgamma(k) - lgamma(a + k + rho + y) + lgamma(a + k + rho) - lgamma(y + 1)
}


tibble(mu = 50) %>% 
  crossing(tibble(y = seq(from = 0, to = 1000, by = 1))) %>% 
  crossing(tibble(k = c(0.1, 0.5, 1, 3, 5, 10)))%>% 
  crossing(tibble(rho = seq(1.1, 10, length.out = 5)))%>% 
  mutate(ld = gwaring_lpmf(y, mu, k, rho))  %>%
    ggplot(aes(x = y, y = ld, color = rho, group = rho)) + geom_line() + facet_wrap(~k, ncol = 3, labeller = "label_both")

```

```{r}
upper_range <- 15
tibble(a = 2) %>% 
  crossing(tibble(y = seq(from = 0, to = upper_range, by = ceiling(upper_range / 100)))) %>% 
  crossing(tibble(k = c(0.1, 0.5, 1, 3, 5, 10)))%>% 
  crossing(tibble(rho = seq(1.1, 10, length.out = 5)))%>% 
  mutate(ld = gwaring_raw_lpmf(y, a, k, rho) %>% exp())  %>%
    ggplot(aes(x = y, y = ld, color = rho, group = rho)) + geom_line() + facet_wrap(~k, ncol = 3, labeller = "label_both")

```


Notes from: https://rss.onlinelibrary.wiley.com/doi/abs/10.2307/2345247
$a$ and $k$ are interchangeable (hence the bimodality)

## Decomposing variance (looks best so far)

The main point is that for $Y \sim Waring(\mu, \rho, k)$ you can decompose the variance as:

$$
Var(Y) = \mu + \tau\mu + \frac{\mu^2}{\phi} \\
\tau = \frac{k + 1}{\rho - 2} \\
\phi = \frac{k ( \rho - 2 )} {k + \rho - 1}
$$ 


So as $\tau \rightarrow 0$ the distribution approaches $NB(\mu, \phi)$. Eventually the $\tau$ parameter controls the shape of the tail in a neat way:


```{r}
rgwaring2 <- function(n, mu, phi, tau) {
   k <-  (tau + 1)*phi
   rho <-  (phi + 1) / tau + phi + 2
   a <-  mu * (rho - 1) / k

   v_logit <- rbeta(n, k, rho)
   
   v <-  v_logit / (1 - v_logit)
   neg_bin_mu = a * v
   rnbinom(n, mu = neg_bin_mu, size = a)
}

gwaring2_lpmf <- function(y, mu, phi, tau) {
   k <-  (tau + 1)*phi
   rho <-  (phi + 1) / tau + phi + 2
   a <-  mu * (rho - 1) / k
   gwaring_lpmf(y, mu, rho, k)
}

main_data <- tibble(mu = 50) %>% 
  crossing(tibble(y = seq(from = 0, to = 1000, by = 1))) %>% 
  crossing(tibble(phi = c(1, 5, 10)))%>% 
  crossing(tibble(tau = c(0.001, 0.1, 1, 10))) %>% 
  mutate(
    k = (tau + 1)*phi,
    rho = (phi + 1) / tau + phi + 2,
    ld = gwaring_lpmf(y, mu = mu, k = k , rho = rho))

nb_data <- main_data %>% filter(y %% 100 == 0) %>%
  mutate(
         nb_dens = dnbinom(y, mu = mu, size = phi, log = TRUE)
         )

main_data %>%
  ggplot(aes(x = y, y = ld, color = as.factor(phi), group = phi)) + 
      geom_point(data = nb_data, aes(y = nb_dens, shape = as.factor(phi))) +
      geom_line() + 
      facet_wrap(~tau, ncol = 2, labeller = "label_both", scales = "free_y")

#main_data %>% mutate(a = mu * (rho - 1) / k) %>% select(a,k,rho, mu, tau, phi) %>% distinct() 
```


The lines show the Waring lpdf, the points are the NB lpdf with the same $\mu$ and $\phi$.

The reverse transformation is:

https://www.wolframalpha.com/input/?i=solve+for+k%2C+rho+%3A+tau+%3D+%28k+%2B+1%29%2F%28rho+-+2%29%3B+phi+%3D+k+*+%28rho+-+2%29+%2F+%28k+%2B+rho++-1%29


$$
k = (\tau + 1) \phi \\
\rho = \frac{\phi + 1}{\tau} + \phi + 2
$$

For $\tau, \phi > 0$. This parametrization doesn't allow you to have $\rho \leq 2$ but that is IMHO OK, because in this case the distribution has infinite variance (and for $\rho \leq 1$ the mean is not defined as well) - which seems mostly undesirable anyway.

```{r}
base_data <- tibble(mu = c(5, 50, 500, 50000)) 

nb_data <- base_data %>%
  crossing(tibble(phi = c(1.1,5))) %>%
  #crossing(tibble(k = c(1, 100, 1000))) %>%
  crossing(tibble(q = seq(1e-1, 1- 1e-5, length.out = 200))) %>%
  group_by(mu) %>%
  mutate(x = qnbinom(q, mu = mu, size = min(phi))) %>%
  ungroup() %>%
  mutate(d_nb = dnbinom(x, mu = mu, size = phi, log = TRUE))

nb_data %>% 
  crossing(tibble(tau = exp(seq(-3,3)))) %>%
  mutate(d = gwaring2_lpmf(x, mu = mu , tau = tau, phi = phi), g = factor(tau)) %>%
  ggplot(aes(x = x, y = d, color = tau )) + geom_line(aes(group = g)) + 
  geom_line(data = nb_data, aes(y = d_nb), color = "red") +
  facet_wrap(phi~mu, scales = "free", labeller = label_both, ncol = 4)
```


## Stefano's approach + symmetry

```{r}
gwaring_stefano_lpmf <- function(y, mu, phi, s) {

  #tau = t * mu + ( mu / (phi * 1) )
  tau = s * mu / phi

  k = (tau + 1)*phi
  rho = (phi + 1) / tau + phi + 2
  gwaring_lpmf(y, mu = mu, k = k , rho = rho)

}

gwaring_stefano2_lpmf <- function(y, mu, phi, r) {
  #phi2 <- (phi + phi^2 + mu * phi * t) / (mu * t + phi * t + mu * t^2)
  #t2 <-  -(-1 -phi +phi2* t)/(mu*t)
  #print(phi2)
  #print(t2)
  s_border <- 0.5 * (sqrt(4*mu + 4 * mu * phi + phi^2) / mu - phi / mu)
  gwaring_stefano_lpmf(y, mu, phi, r + s_border)
}
  
rgwaring_stefano2 <- function(n, mu, phi, r) {
  s_border <-  0.5 * (sqrt(4*mu + 4 * mu * phi + phi^2) / mu - phi / mu);
  tau <-  (s_border + r) * mu / phi;
  rgwaring2(n, mu, phi, tau)
}

# mu <- c(500); 
# phi <- c(0.1,0.5,1,5); 
mu <- c(5,50,500,5000); 
phi <- c(5); 
r <- seq(0.01,2, length.out = 8)



base <- tibble(mu = mu) %>%
  crossing(tibble(phi = phi))%>% 
  mutate(low_bound = qnbinom(0.025, mu = mu, size = phi),
         high_bound = qnbinom(0.975, mu = mu, size = phi)
         ) %>%
  crossing(tibble(y_step = seq(0,1, length.out = 100))) %>% 
  mutate(y = round(low_bound + (high_bound - low_bound) * y_step))



main_data <- base %>% 
  crossing(tibble(r = r)) %>% 
  mutate(
    ld = gwaring_stefano2_lpmf(y, mu = mu, phi = phi, r = r))

nb_data <- base %>% mutate(
         nb_dens = dnbinom(y, mu = mu, size = phi, log = TRUE)
         )

main_data %>%
  ggplot(aes(x = y, y = ld, color = r, group = r)) + 
      geom_line(data = nb_data, aes(x = y, y = nb_dens), inherit.aes = FALSE, color = "red") +
      geom_line() + 
      facet_wrap(mu~phi, ncol = 2, labeller = "label_both", scales = "free")

```

```{r}
pair_data <- tibble(mu = c(5, 50, 500, 5000)) %>%
  crossing(phi = exp(seq(log(0.1), log(5), length.out = 100))) %>%
  crossing(s = exp(seq(log(0.1), log(5), length.out = 100))) %>%
  mutate(phi2 = (phi + phi^2 + mu * phi * s) / (mu * s + phi * s + mu * s^2),
         s2 = -(-1 -phi +phi2* s)/(mu*s), 
         s_border = 0.5 * (sqrt(4*mu + 4 * mu * phi + phi^2) / mu - phi / mu)) 
  
# pair_data  %>%
#   ggplot(aes(x = phi, y = s, fill = s2)) + geom_raster() + scale_x_log10() + scale_y_log10() + facet_wrap(~mu)
# 
# pair_data  %>%
#   ggplot(aes(x = phi, y = s, fill = phi2)) + geom_raster() + scale_x_log10() + scale_y_log10() + facet_wrap(~mu)

pair_data  %>%
  ggplot(aes(x = phi, y = s, fill = s_border)) + geom_raster() + scale_x_log10() + scale_y_log10() + facet_wrap(~mu) + scale_fill_continuous(trans = "log10")


```




```{r}
# tibble(mu = 50) %>% 
#   crossing(tibble(y = seq(from = 0, to = 1000, by = 1))) %>% 
#   crossing(tibble(mu_beta = c(0.01, 0.1, 0.3, 0.5, 0.7, 0.9,0.99)))%>% 
#   crossing(tibble(prec_beta = 10^seq(-2, 3))) %>% 
#   mutate(
#       rho = mu_beta * prec_beta,
#       k = prec_beta - rho,
#       ld = gwaring_lpmf(y, mu, k = k, rho = rho))  %>%
#     ggplot(aes(x = y, y = ld, color = mu_beta, group = mu_beta)) + geom_line() + facet_wrap(~prec_beta, ncol = 3, labeller = "label_both", scales = "free_y")
```

```{r}


mu <- 100
phi <- 8
tau <- 3

rng_vals <- rgwaring2(1e6, mu, phi, tau)
cat("Expected mean: ", mu, " actual: ", mean(rng_vals),"\n")
cat("Expected variance: ", mu + tau * mu + mu^2 / phi, " actual: ", var(rng_vals),"\n")

density_points <- seq(0, quantile(rng_vals, 0.99), length.out = 100)

data.frame(x = rng_vals) %>% ggplot(aes(x)) + geom_density(kernel = "optcosine", adjust = 3) + geom_line(aes(x = x, y = y), data = data.frame(x = density_points, y = exp(gwaring2_lpmf(density_points, mu, phi, tau))), color = "blue")
```


```{r}
test_model <- stan_model(here("stan", "waring_simple_test.stan"))
```

```{r}
generator <- function(N) {
  function() {
    mu <- rlnorm(1, 3, 1)
    phi <- 1/sqrt(abs(rnorm(1, 0, 1)))
    r <- abs(rnorm(1, 0, 5))
    
    list( true = list(mu = mu, phi = phi, r = r), 
          observed = list(N = N, y = rgwaring_stefano2(N, mu, phi, r)))
  }
}

set.seed(6988225)
cache_dir <- here("local_temp_data","sbc_waring")
if(!dir.exists(cache_dir)) {
  dir.create(cache_dir, recursive = TRUE)
}
sbc_res <- sbc(test_model, generator(100), N_steps = 100, cache_dir = cache_dir)

```


```{r}
summarise_sbc_diagnostics(sbc_res)
sbc_res$diagnostics

plot_sbc_params(sbc_res$params, binwidth = 10)

sbc_res$params %>% filter(param_name == "mu") %>% 
  inner_join(sbc_res$diagnostics, by = c("run" = "run")) %>%
  mutate(max_rhat = pmin(max_rhat, 2)) %>%
  ggplot(aes(x = true_value, y = n_divergent)) + geom_point() 
```


```{r}
run <- 7
fit <- 1:4 %>% purrr::map( ~ readRDS(here("local_temp_data","sbc_waring",sprintf("%06d.rds",(run - 1) * 4 + .x)))$fit) %>% sflist2stanfit
launch_shinystan_nonblocking(fit)

sbc_res$true_values[[run]]
hist(sbc_res$data[[run]]$y)
```

```{r}
#fit
fit %>% rstan::extract() %>% as_tibble() %>% as_tibble() %>%
  mutate(q = (tau + 1) / phi, 
         s_b = 0.5 * (sqrt(4*mu + 4 * mu * phi + phi^2) / mu - phi / mu),
         s_raw = tau + s_b,
         phibar =(phi + phi^2 + mu * phi * s_raw) / (mu *s_raw + phi * s_raw + mu * s_raw^2),
         sbar = -(-1 -phi +phibar* s_raw)/(mu*s_raw)
         ) %>%
  ggplot(aes(x = log(s_b), y = log(phi))) + geom_point()

```


```{r}
sbc_res$params %>% 
  filter(param_name == "mu") %>%
  inner_join(sbc_res$params %>% filter(param_name == "tau"), by = c("run" = "run"), suffix = c(".mu",".tau")) %>%
ggplot(aes(x = median.mu, y = median.tau)) + geom_point(alpha = 0.1)
```

