---
title: "Comparison with K-fold cross validation"
output: html_notebook
---

```{r setup}
set.seed(13254)

# Import libraries
library(tidyverse)
library(magrittr)
library(rstan)
library(tidybayes)
library(here)
library(foreach)
library(doParallel)
library(loo)
library(matrixStats)
registerDoParallel()
# library(future)
# plan(multiprocess)

rstan_options(auto_write = TRUE)
options(mc.cores = parallel::detectCores())
```


```{r}

N = 50
G = 10
counts_source = "Acute_Myeloid_Leukemia_Primary_Blood_Derived_Cancer_-_Peripheral_Blood"

counts_tidy <- load_test_data(N, G, counts_source)
data_for_stan = data_for_stan_from_tidy(N, G, counts_tidy)
```

```{r}
model_names = c(
  "multinomial",
  "dirichlet_multinomial",
  "negBinomial"
  #"gamma_multinomial"
  )
```

```{r, echo=FALSE}
models =
  foreach(model_name = model_names) %dopar% {
    library(rstan) #On Windows, %dopar%-ed code does not share the main session
    library(here) #On Windows, %dopar%-ed code does not share the main session
    stan_model(here("stan",sprintf("%s.stan", model_name)))
  } %>%
  setNames(model_names)
```


```{r}
K = 5
model_defs = tibble(model_name = model_names) %>% crossing(fold = 1:K)

folds = kfold_split_random(K, N)

models_list = models[model_defs$model_name]

#Copy the data for all runs
data_list = list()
for(i in 1:nrow(model_defs)) {
  data_list[[i]] = data_for_stan
  data_list[[i]]$holdout = (folds == model_defs$fold[i])
}

fits = sampling_multi(models_list, data_list)
```


```{r}
#Functions taken from
#https://github.com/stan-dev/stancon_talks/blob/master/2017/Contributed-Talks/07_nicenboim/kfold.Rmd

extract_log_lik_K <- function(list_of_stanfits, list_of_holdout, ...){
  K <- length(list_of_stanfits)
  list_of_log_liks <- plyr::llply(1:K, function(k){
    extract_log_lik(list_of_stanfits[[k]],...)
  })
    # `log_lik_heldout` will include the loglike of all the held out data of all the folds.
  # We define `log_lik_heldout` as a (samples x N_obs) matrix
  # (similar to each log_lik matrix)
  log_lik_heldout <- list_of_log_liks[[1]] * NA
  for(k in 1:K){
    log_lik <- list_of_log_liks[[k]]
    samples <- dim(log_lik)[1] 
    N_obs <- dim(log_lik)[2]
    # This is a matrix with the same size as log_lik_heldout
    # with 1 if the data was held out in the fold k
    heldout <- matrix(rep(list_of_holdout[[k]], each = samples), nrow = samples)
    # Sanity check that the previous log_lik is not being overwritten:
    if(any(!is.na(log_lik_heldout[heldout==1]))){
      warning("Heldout log_lik has been overwritten!!!!")
    }
    # We save here the log_lik of the fold k in the matrix:
    log_lik_heldout[heldout==1] <- log_lik[heldout==1]
  }
  return(log_lik_heldout)
}

kfold <- function(log_lik_heldout)  {
  library(matrixStats)
  logColMeansExp <- function(x) {
    # should be more stable than log(colMeans(exp(x)))
    S <- nrow(x)
    colLogSumExps(x) - log(S)
  }
  # See equation (20) of @VehtariEtAl2016
  pointwise <-  matrix(logColMeansExp(log_lik_heldout), ncol= 1)
  colnames(pointwise) <- "elpd"
  # See equation (21) of @VehtariEtAl2016
  elpd_kfold <- sum(pointwise)
  se_elpd_kfold <-  sqrt(ncol(log_lik_heldout) * var(pointwise))
  out <- list(
  pointwise = pointwise,
  elpd_kfold = elpd_kfold,
  se_elpd_kfold = se_elpd_kfold)
  structure(out, class = "loo")
}
```


```{r}
kfold_res <- model_names %>% map(function(model_name) { 
  indices = model_defs$model_name == model_name
  fits_for_model <- fits[indices]
  holdout_for_model <- lapply(data_list[indices], '[[', "holdout")
  extract_log_lik_K(fits_for_model, holdout_for_model, "log_lik")
}) %>% 
  map(kfold) %>%
  set_names(model_names)
```


```{r}
compare(x = kfold_res)
```

